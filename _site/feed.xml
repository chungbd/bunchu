<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="3.4.5">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" /><updated>2017-07-12T16:16:30+07:00</updated><id>http://localhost:4000/</id><title type="html">Chung Bui</title><subtitle>My biography, profile and curriculum vitae</subtitle><entry><title type="html">Protocol in Swift</title><link href="http://localhost:4000/Protocol-in-Swift/" rel="alternate" type="text/html" title="Protocol in Swift" /><published>2017-07-06T22:00:00+07:00</published><updated>2017-07-06T22:00:00+07:00</updated><id>http://localhost:4000/Protocol-in-Swift</id><content type="html" xml:base="http://localhost:4000/Protocol-in-Swift/">&lt;h2 id=&quot;khái-niệm&quot;&gt;Khái niệm:&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;protocol /Noun /ˈprəʊtəkɒl/: A set of rules governing the exchange or transmission of data between devices. &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;trong Tiếng việc có nghĩa là giao thức, định chuẩn&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;A protocol defines a blueprint of methods, properties, and other requirements that suit a particular task or piece of functionality.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;blockquote&gt;
  &lt;p&gt;A blueprint is a reproduction of a technical drawing, documenting an architecture or an engineering design, using a contact print process on light-sensitive sheets.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Nói một cách ngắn ngọn, protocol là giống như việc bạn định nghĩa trước hành vi, cấu trúc của một viewcontroller trong swift, rộng hơn là kiến trúc của toàn ứng dụng.&lt;/p&gt;

&lt;p&gt;VD: Ta có hai màn hình A và B, từ màn hình A sang màn hình B,&lt;/p&gt;

&lt;h2 id=&quot;cú-pháp---syntax&quot;&gt;Cú pháp - Syntax:&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    protocol MyProtocol {
        // protocol definition goes here
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;It is the same as declarations of class, structure and enumeration&lt;/p&gt;

&lt;p&gt;A protocol could have a super protocol, it means its inheribility&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    protocol MyProtocol, FirstProtocol, SecondProtocol {
        // protocol definition goes here
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;rằng-buộc-về-thuộc-tính---property-requirements-&quot;&gt;Rằng buộc về thuộc tính - Property Requirements .&lt;/h2&gt;

&lt;p&gt;Một protocol có thể yêu cầu đối tượng thể hiện bởi Protocol đó cung cấp một thuộc tính chỉ với một tên biến và loại dữ liệu của biến đó.&lt;/p&gt;

&lt;p&gt;Không phân biệt nó là &lt;strong&gt;thuộc tính lưu trữ(stored property)&lt;/strong&gt; hay &lt;strong&gt;thuộc tính được tính toán(Computed property)&lt;/strong&gt;.&lt;/p&gt;

&lt;p&gt;Ta có ví dụ cho hai trường hợp trên như sau:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protocol FullNamed {
    var firstName:String { set get }
    var lastName:String { set get }
    
    var fullName:String { get }
}


struct Person:FullNamed {
    var firstName: String
    var lastName: String
    
    var fullName: String {
        return &quot;\(lastName) \(firstName)&quot;
    }
}

let person = Person(firstName: &quot;Benjamin&quot;, lastName: &quot;Bui&quot;)

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;Ta khai báo một lớp Person mà có rằng buộc biến được khai báo từ protocol FullNamed. Với firstName và lastName là hai thuộc tính có thể gán lại được giá trị và
lấy được giá trị.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;error: variable with a setter must also have a getter&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;set&lt;/strong&gt; không bao giờ đứng một mình trong &lt;strong&gt;protocol&lt;/strong&gt;, với &lt;strong&gt;get&lt;/strong&gt; thì ngược lại, có thể đứng một mình.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;rằng-buộc-về-phương-thức-trên-trong-protocol---method-requirements&quot;&gt;Rằng buộc về phương thức trên trong protocol - Method requirements&lt;/h2&gt;
&lt;p&gt;The following example will extend the above protocol with specific instance methods.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protocol FullNamed {
    var firstName:String { set get }
    var lastName:String { set get }
    
    func getFullName() -&amp;gt; String
}

struct Person:FullNamed {
    var firstName: String
    var lastName: String
    
    init(firstName:String,lastName:String) {
        self.firstName = firstName
        self.lastName = lastName
    }
    
    func getFullName() -&amp;gt; String {
        return &quot;\(lastName) \(firstName)&quot;
    }
}
let person = Person(firstName: &quot;Benjamin&quot;, lastName: &quot;Bui&quot;)
print(person.getFullName())

/* output 
 Bui Benjamin
 
 */

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;rằng-buộc-khởi-tạo---initializer-requirements&quot;&gt;Rằng buộc khởi tạo - Initializer Requirements&lt;/h2&gt;

&lt;h2 id=&quot;rằng-buộc-phương-thức-thay-đổi---mutating-method-requirements&quot;&gt;Rằng buộc phương thức thay đổi - Mutating Method Requirements&lt;/h2&gt;

&lt;p&gt;It mean you will declare a function in struct or enumeration where you can change value of property in, because you can not change value of property in normal function.&lt;/p&gt;

&lt;p&gt;With protocol, to do this you have to add prefix &lt;strong&gt;mutating&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protocol FullNamed {
    var firstName:String { set get }
    var lastName:String { set get }
    
    mutating func setName(withAnotherFullname fullname:FullNamed)
}

struct Person:FullNamed {
    ...
    mutating func setName(withAnotherFullname fullname: FullNamed) {
        firstName = fullname.firstName
        lastName = fullname.lastName
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;protocol-là-một-loại-dữ-liệu---protocols-as-types&quot;&gt;Protocol là một loại dữ liệu - Protocols as Types&lt;/h2&gt;

&lt;p&gt;Because it is a type, you can use a protocol in many places where other types are allowed, including:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;As a parameter type or return type in a function, method, or initializer&lt;/li&gt;
  &lt;li&gt;As the type of a constant, variable, or property&lt;/li&gt;
  &lt;li&gt;As the type of items in an array, dictionary, or other container&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;sự-ủy-quyền---delegation&quot;&gt;Sự ủy quyền - Delegation:&lt;/h2&gt;

&lt;p&gt;It is a design pattern that enables a class or structure to delegate some of its responsibilities to an instance of another type.&lt;/p&gt;

&lt;p&gt;We are a example about modeling a people in love&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protocol InLovePeople {
    var lover:String { get set }
    
    func startTheRelationship()
}

protocol InLovePeopleDelegate {
    func peopleDidGoOutTogether(people:InLovePeople)
    func peopleDidStopRelationship(people:InLovePeople)
    func peopleWillMakeWedding(people:InLovePeople)
}


class InLoveMan:InLovePeople {
    var lover: String
    
    var delegate:InLovePeopleDelegate?
    
    init(loverName:String) {
        lover = loverName
    }
    
    func startTheRelationship() {
        if lover == &quot;Not Good&quot; {
            delegate?.peopleDidStopRelationship(people: self)
        }
    }
}

class PeopleTracker:InLovePeopleDelegate {
    
    func peopleWillMakeWedding(people: InLovePeople) {
        print(&quot;We will be so happy!&quot;)
    }
    
    func peopleDidGoOutTogether(people: InLovePeople) {
        print(&quot;It's a good sign!&quot;)
    }
    
    func peopleDidStopRelationship(people: InLovePeople) {
        print(&quot;Poor you!&quot;)
    }
}


let man = InLoveMan(loverName: &quot;Su Su&quot;)
let tracker = PeopleTracker()
man.delegate = tracker
man.startTheRelationship()

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;
Because a delegate isn’t required in order to do action like as its instance, the delegate property is defined as an optional&lt;/p&gt;

&lt;h2 id=&quot;thêm-tương-thích-giao-thức-với-một-mở-rộng---adding-protocol-conformance-with-an-extension&quot;&gt;Thêm tương thích giao thức với một mở rộng - Adding Protocol Conformance with an Extension.&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;You can extend an existing type to adopt and conform to a new protocol, even if you do not have access to the source code for the existing type.&lt;/li&gt;
  &lt;li&gt;Extensions can add new properties, methods, and subscripts to an existing type.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protocol InLovePeople {
    var lover:String { get set }
    
    func startTheRelationship()
}

extension InLoveMan: InLovePeople {
    var faceExpression: String {
        return &quot;It look like confident and enjoyable with life&quot;
    }
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;việc-khai-báo-làm-theo-với-một-sự-mở-rộng---declaring-protocol-adoption-with-an-extension&quot;&gt;Việc khai báo làm theo với một sự mở rộng - Declaring Protocol Adoption with an Extension.&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;If a type already conforms to all of the requirements of a protocol, but has not yet stated that it adopts that protocol, you can make it adopt the protocol with an empty extension:&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class InLoveMan {
    var lover: String
    
    var delegate:InLovePeopleDelegate?
    
    init(loverName:String) {
        lover = loverName
    }
    
    func startTheRelationship() {
        if lover == &quot;Not Good&quot; {
            delegate?.peopleDidStopRelationship(people: self)
        }
    }
}

class InLoveMan:InLovePeople { }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Types do not automatically adopt a protocol. They must always explicitly declare their adoption of the protocol.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;việc-kế-thừa-của-giao-thức---protocol-inheritance&quot;&gt;Việc kế thừa của giao thức - Protocol Inheritance:&lt;/h2&gt;

&lt;p&gt;A protocol can inherit one or more other protocols and can add further requirements on top of the requirements it inherits.&lt;/p&gt;

&lt;h2 id=&quot;các-giao-thức-chỉ-giành-cho-lớp---class-only-protocols&quot;&gt;Các giao thức chỉ giành cho lớp - Class-Only Protocols:&lt;/h2&gt;

&lt;p&gt;You can limit protocol adoption to class types (and not structures or enumerations) by adding the AnyObject protocol to a protocol’s inheritance list.&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;protocol SomeClassOnlyProtocol: AnyObject, SomeInheritedProtocol {
    // class-only protocol definition goes here
}
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;sự-kết-hợp-giữa-các-giao-thức---protocol-composition&quot;&gt;Sự kết hợp giữa các giao thức - Protocol Composition&lt;/h2&gt;

&lt;h2 id=&quot;continue-updating&quot;&gt;Continue updating&lt;/h2&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference:&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://developer.apple.com/library/content/documentation/Swift/Conceptual/Swift_Programming_Language/Protocols.html&quot;&gt;Protocols - Apple&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Bun Chu</name></author><category term="blog" /><category term="Foundation" /><category term="Swift" /><category term="Protocol" /><summary type="html">Khái niệm:</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/markdown.jpg" /></entry><entry><title type="html">Application Lifecycle in iOS</title><link href="http://localhost:4000/Application-Lifecycle-in-iOS/" rel="alternate" type="text/html" title="Application Lifecycle in iOS" /><published>2017-06-16T22:00:00+07:00</published><updated>2017-06-16T22:00:00+07:00</updated><id>http://localhost:4000/Application-Lifecycle-in-iOS</id><content type="html" xml:base="http://localhost:4000/Application-Lifecycle-in-iOS/">&lt;h2 id=&quot;loading-application&quot;&gt;Loading Application&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;The user has just turned on his phone, and no applications are running expect for those that belong to the operating system.&lt;/li&gt;
  &lt;li&gt;Your application is &lt;strong&gt;not running.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;After the user taps your app’s icon, &lt;strong&gt;Springboard&lt;/strong&gt; - the part of the OS that operates the Home screen of iOS - launches your app.&lt;/li&gt;
  &lt;li&gt;Your app, and the shared libraries it needs to execute, is loaded into memory while Springboard animates your &lt;em&gt;Default.png&lt;/em&gt; on the screen&lt;/li&gt;
  &lt;li&gt;Eventually, your app begins execution, and your &lt;em&gt;application delegate&lt;/em&gt; receives the appropriate notification.&lt;/li&gt;
  &lt;li&gt;When your application is running and in the foreground, &lt;strong&gt;it is in the active state.&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;stopping-application&quot;&gt;Stopping Application&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;On iOS, users tend to only use any given application for a few seconds before returning their phones to their pockets.
    &lt;ul&gt;
      &lt;li&gt;After the user has put away your app by pressing the Home button on her iPhone or iPad, your application enters &lt;strong&gt;the background state&lt;/strong&gt;&lt;/li&gt;
      &lt;li&gt;Typically, apps have 10 seconds to complete any database saves or other long-running tasks(though applications can request additional time from the OS).&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;When all the background processing is complete, the application finally becomes &lt;strong&gt;suspended state&lt;/strong&gt;.
    &lt;ul&gt;
      &lt;li&gt;While &lt;strong&gt;suspended&lt;/strong&gt;, applications remain in memory but may not execute code.&lt;/li&gt;
      &lt;li&gt;The state of your application is persisted.&lt;/li&gt;
      &lt;li&gt;If the user opens your application while it is suspended, it begins execution exactly where it left off.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;If memory becomes low, the OS can kill your app while it is in the suspended state. The user can also manually terminal your app from multitasking tray.
    &lt;ul&gt;
      &lt;li&gt;Once terminated, applications &lt;strong&gt;return to their initial state of not running.&lt;/strong&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;awaking-application&quot;&gt;Awaking Application&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;If the user receives a calendar alert, opens the multitasking tray, or gets a phone call, your application can be put into &lt;strong&gt;the inactive state.&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;The user can open your application without tapping its icon on the Home screen.
    &lt;ul&gt;
      &lt;li&gt;If your application receives local or push notifications, or if it is registered for custom URL scheme handing, the user can open it in any number of ways.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;reference&quot;&gt;Reference&lt;/h2&gt;
&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;&quot;&gt;Chater 1 - iOS UICollectionView - The complete guide, 2nd Edition&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>Bun Chu</name></author><category term="blog" /><category term="Foundation" /><category term="Swift" /><category term="Lifecycle" /><summary type="html">Loading Application The user has just turned on his phone, and no applications are running expect for those that belong to the operating system. Your application is not running. After the user taps your app’s icon, Springboard - the part of the OS that operates the Home screen of iOS - launches your app. Your app, and the shared libraries it needs to execute, is loaded into memory while Springboard animates your Default.png on the screen Eventually, your app begins execution, and your application delegate receives the appropriate notification. When your application is running and in the foreground, it is in the active state.</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/markdown.jpg" /></entry><entry><title type="html">Injection Plugin for Xcode</title><link href="http://localhost:4000/injection-plugin-in-xcode/" rel="alternate" type="text/html" title="Injection Plugin for Xcode" /><published>2017-05-22T19:30:00+07:00</published><updated>2017-05-22T19:30:00+07:00</updated><id>http://localhost:4000/injection-plugin-in-xcode</id><content type="html" xml:base="http://localhost:4000/injection-plugin-in-xcode/">&lt;h2 id=&quot;i---mục-đích&quot;&gt;I - Mục đích:&lt;/h2&gt;
&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/johnno1962/injectionforxcode/master/documentation/images/injected.gif&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Nó sẽ giả lập lại chế độ debug giống như trên nền tảng React Native. Nghĩa là bạn chỉ cần bấm một tổ hợp phím(ở đây là ‘Ctrl + =’), toàn bộ những thay đổi của bạn trên code sẽ được cập nhập trên Simulator - phần mềm giả lập thiết bị.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ii---cài-đặt&quot;&gt;II - Cài đặt:&lt;/h2&gt;
&lt;p&gt;Mình sẽ trình bày cho việc sử dụng Injection trên Xcode và AppCode(cái này mới thịnh hành)&lt;/p&gt;
&lt;h3 id=&quot;xcode&quot;&gt;Xcode&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Unsign Xcode: nghĩa là bạn sẽ phải tạo ra một phiên bản khác cho Xcode, để phục vụ quá trình injection.
    &lt;ul&gt;
      &lt;li&gt;Tải hoặc git clone &lt;a href=&quot;https://github.com/johntmcintosh/xcunsign&quot;&gt;https://github.com/johntmcintosh/xcunsign&lt;/a&gt;&lt;/li&gt;
      &lt;li&gt;Chạy trực tiếp script để tiến hành unsign.
Ví dụ: mình sử dụng phiên bản Xcode 8.2.1
&lt;img src=&quot;http://localhost:4000/assets/post/2017/injection/unsign.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
&lt;img src=&quot;http://localhost:4000/assets/post/2017/injection/unsign_1.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Cài đặt Injection plugin: có 2 cách&lt;/p&gt;

    &lt;p&gt;A. Tải file zip hoặc clone &lt;a href=&quot;https://github.com/johnno1962/injectionforxcode&quot;&gt;https://github.com/johnno1962/injectionforxcode&lt;/a&gt; - Mình sử dụng cách này.&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;Trong thư mục InjectionPluginLite, mở file .xcodeproj&lt;/li&gt;
      &lt;li&gt;Thực hiện build the scheme InjectionPluginLite&lt;/li&gt;
    &lt;/ul&gt;

    &lt;p&gt;B. Tải bản beta từ trang cá nhân của tác giả &lt;a href=&quot;http://johnholdsworth.com/injection.html&quot;&gt;http://johnholdsworth.com/injection.html&lt;/a&gt;&lt;/p&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&quot;https://johntmcintosh.com/blog/2016/10/03/code-injection-ios&quot;&gt;Tham khảo&lt;/a&gt;&lt;/p&gt;
&lt;h3 id=&quot;appcode&quot;&gt;AppCode:&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Tải file jar mới nhất cho AppCode &lt;a href=&quot;https://raw.githubusercontent.com/johnno1962/InjectionApp/master/InjectionAppCode/Injection.jar&quot;&gt;tại đây&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;Vào Preference -&amp;gt; Plugins -&amp;gt; Install plugin from disk -&amp;gt; Link to dowloaded jar file&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Thật sự là việc cài đặt này phụ thuộc rất nhiều vào việc cô có thương bạn ngày hôm đó không.&lt;/li&gt;
  &lt;li&gt;Mình đã mất một ngày ngồi chỉ để tìm cách làm sao cho nó chạy được trên AppCode và Xcode.&lt;/li&gt;
  &lt;li&gt;Mình khuyên các bạn sử dụng Xcode vì nó free và không gây nhiều lỗi như AppCode(thật sự là chả giá rất nhiều cho nó)&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ii---sử-dụng&quot;&gt;II - Sử dụng:&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Trong một class của một View Controller bất gì của một màn hình nào đó.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cách-1-sử-dụng-bên-trong-view-controller&quot;&gt;&lt;strong&gt;Cách 1:&lt;/strong&gt; sử dụng bên trong View Controller&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    func injected() {
        print(&quot;I've been injected: \(self)&quot;)
    }
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;Thực hiện built và chạy trên Simulator.&lt;/li&gt;
  &lt;li&gt;Khi View Controller trên hiện ra. Nhấn tổ hợp phím ‘Ctrl + =’. Một đoạn log sẽ được hiện ra dưới Debug area như bên dưới. Nghĩa là bạn đã cài đặt và sử dụng thành công.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/post/2017/injection/unsign_2.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Mỗi lần sử dụng thao tác này, code sẽ chạy vào hàm injected, thực hiện dòng lệnh nếu có thay đổi code. Thay thử vài thao tác cơ bản để thấy sự khác biệt.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;  func injected() {
      print(&quot;I've been injected: \(self)&quot;)
      view.backgroundColor = .darkText
  }
&lt;/code&gt;&lt;/pre&gt;
    &lt;/div&gt;
    &lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/post/2017/injection/unsign_3.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;Vào nhớ Cmd + S để save lại trạng thái trước khi thử.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;cách-2-sử-dụng-một-view-controller-có-nhiệm-vụ-điều-hướng-đến-viewcontroller-cần-inject-code&quot;&gt;&lt;strong&gt;Cách 2:&lt;/strong&gt; Sử dụng một view controller có nhiệm vụ điều hướng đến viewcontroller cần inject code&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Khởi tạo một navigation controller có root controller là TestingInjectionVC.&lt;/li&gt;
  &lt;li&gt;Trong TestingInjectionVC.swift, khởi tạo một bộ quan sát với định danh là INJECTION_BUNDLE_NOTIFICATION. Khi nhận được notification từ định danh trên, navigation hiện tại sẽ push đến injected view controller.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http://localhost:4000/assets/post/2017/injection/injectionNoticationName.png&quot; alt=&quot;Markdowm Image&quot; /&gt;
&lt;img src=&quot;http://localhost:4000/assets/post/2017/injection/injectionNotication.png&quot; alt=&quot;Markdowm Image&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Note:&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Với mình, cách xử lý thứ 2 hiệu quả hơn cho những màn hình cần thiết lại giao diện, theo ý đồ của mình đó là view luôn được chạy lại.&lt;/li&gt;
  &lt;li&gt;Với cách 1, mình chỉ sử dụng khi muốn kiểm chứng với một vài chi tiết nhỏ thay đổi như màu, text conent.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;iii---sự-tồn-tại-của-plugin-này-và-trường-phái-chống-lại-interface-builder&quot;&gt;III - Sự tồn tại của Plugin này và trường phái chống lại Interface Builder&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Về công dụng, Plugin này khiến khích bạn lập trình giao diện bằng code nhiều hơn. Nó làm bạn biết sự thay đổi của từng dòng code lên giao diện trong vòng 2 giây&lt;/li&gt;
  &lt;li&gt;Đối nghịch lại khi bạn sử dụng trên Interface Builder(một kiểu lập trình kéo thả giao diện, rất hợp với các designer muốn code giao diện), bạn sẽ phải rebuild lại ứng dụng để thấy sự thay đổi, quá trình đó thực hiện trong vòng 20 giây&lt;/li&gt;
  &lt;li&gt;Sự đối nghịch trên càng lớn hơn với những dự án lớn nhiều màn hình và kéo dài nhiều năm.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Một vài link để tham khảo về ưu nhược điểm khi sử dụng Interface Builder:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.raizlabs.com/dev/2016/08/ib-free-living-without-interface-builder/&quot;&gt;IB Free: Living Without Interface Builder and Loving It&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://blog.zeplin.io/life-without-interface-builder-adbb009d2068&quot;&gt;Life without Interface Builder&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.quora.com/Which-is-better-for-iOS-apps-storyboards-or-programmatic-development&quot;&gt;Which is better for iOS apps: storyboards or programmatic development?&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://www.quora.com/Does-the-Facebook-iOS-app-use-storyboards&quot;&gt;Does the Facebook iOS app use storyboards?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;tham-khảo&quot;&gt;Tham khảo:&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/johnno1962/injectionforxcode&quot;&gt;https://github.com/johnno1962/injectionforxcode&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://johntmcintosh.com/blog/2016/10/03/code-injection-ios&quot;&gt;https://johntmcintosh.com/blog/2016/10/03/code-injection-ios&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://johntmcintosh.com/blog/2016/09/30/xcode8-extensions&quot;&gt;https://johntmcintosh.com/blog/2016/09/30/xcode8-extensions&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://github.com/johnno1962/InjectionApp&quot;&gt;https://github.com/johnno1962/InjectionApp&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://johnholdsworth.com/injection.html&quot;&gt;http://johnholdsworth.com/injection.html&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;https://karlbowden.com/quick-start-hot-reloading-in-swift/&quot;&gt;https://karlbowden.com/quick-start-hot-reloading-in-swift/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content><author><name>bunchu</name></author><category term="blog" /><category term="injection" /><category term="xcode" /><category term="auto-layout" /><summary type="html">I - Mục đích:</summary><media:thumbnail xmlns:media="http://search.yahoo.com/mrss/" url="http://localhost:4000/assets/images/markdown.jpg" /></entry></feed>